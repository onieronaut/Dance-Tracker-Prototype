schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false
  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
columns and relationships of "active_rotation"
"""
type ActiveRotation {
  """An object relationship"""
  currentUserRotation: CurrentUserRotation
  id: uuid
  index: Int
  isActive: Boolean
  name: String
  type: String
  userId: uuid
}

"""
aggregated selection of "active_rotation"
"""
type ActiveRotationAggregate {
  aggregate: ActiveRotationAggregateFields
  nodes: [ActiveRotation!]!
}

"""
aggregate fields of "active_rotation"
"""
type ActiveRotationAggregateFields {
  avg: ActiveRotationAvgFields
  count(columns: [ActiveRotationSelectColumn!], distinct: Boolean): Int!
  max: ActiveRotationMaxFields
  min: ActiveRotationMinFields
  stddev: ActiveRotationStddevFields
  stddevPop: ActiveRotationStddevPopFields
  stddevSamp: ActiveRotationStddevSampFields
  sum: ActiveRotationSumFields
  varPop: ActiveRotationVarPopFields
  varSamp: ActiveRotationVarSampFields
  variance: ActiveRotationVarianceFields
}

"""aggregate avg on columns"""
type ActiveRotationAvgFields {
  index: Float
}

"""
Boolean expression to filter rows from the table "active_rotation". All fields are combined with a logical 'AND'.
"""
input ActiveRotationBoolExp {
  _and: [ActiveRotationBoolExp!]
  _not: ActiveRotationBoolExp
  _or: [ActiveRotationBoolExp!]
  currentUserRotation: CurrentUserRotationBoolExp
  id: UuidComparisonExp
  index: IntComparisonExp
  isActive: BooleanComparisonExp
  name: StringComparisonExp
  type: StringComparisonExp
  userId: UuidComparisonExp
}

"""
input type for incrementing numeric columns in table "active_rotation"
"""
input ActiveRotationIncInput {
  index: Int
}

"""
input type for inserting data into table "active_rotation"
"""
input ActiveRotationInsertInput {
  currentUserRotation: CurrentUserRotationObjRelInsertInput
  id: uuid
  index: Int
  isActive: Boolean
  name: String
  type: String
  userId: uuid
}

"""aggregate max on columns"""
type ActiveRotationMaxFields {
  id: uuid
  index: Int
  name: String
  type: String
  userId: uuid
}

"""aggregate min on columns"""
type ActiveRotationMinFields {
  id: uuid
  index: Int
  name: String
  type: String
  userId: uuid
}

"""
response of any mutation on the table "active_rotation"
"""
type ActiveRotationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ActiveRotation!]!
}

"""Ordering options when selecting data from "active_rotation"."""
input ActiveRotationOrderBy {
  currentUserRotation: CurrentUserRotationOrderBy
  id: OrderBy
  index: OrderBy
  isActive: OrderBy
  name: OrderBy
  type: OrderBy
  userId: OrderBy
}

"""
select columns of table "active_rotation"
"""
enum ActiveRotationSelectColumn {
  """column name"""
  id
  """column name"""
  index
  """column name"""
  isActive
  """column name"""
  name
  """column name"""
  type
  """column name"""
  userId
}

"""
input type for updating data in table "active_rotation"
"""
input ActiveRotationSetInput {
  id: uuid
  index: Int
  isActive: Boolean
  name: String
  type: String
  userId: uuid
}

"""aggregate stddev on columns"""
type ActiveRotationStddevFields {
  index: Float
}

"""aggregate stddevPop on columns"""
type ActiveRotationStddevPopFields {
  index: Float
}

"""aggregate stddevSamp on columns"""
type ActiveRotationStddevSampFields {
  index: Float
}

"""
Streaming cursor of the table "active_rotation"
"""
input ActiveRotationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ActiveRotationStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ActiveRotationStreamCursorValueInput {
  id: uuid
  index: Int
  isActive: Boolean
  name: String
  type: String
  userId: uuid
}

"""aggregate sum on columns"""
type ActiveRotationSumFields {
  index: Int
}

input ActiveRotationUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ActiveRotationIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: ActiveRotationSetInput
  """filter the rows which have to be updated"""
  where: ActiveRotationBoolExp!
}

"""aggregate varPop on columns"""
type ActiveRotationVarPopFields {
  index: Float
}

"""aggregate varSamp on columns"""
type ActiveRotationVarSampFields {
  index: Float
}

"""aggregate variance on columns"""
type ActiveRotationVarianceFields {
  index: Float
}

"""
columns and relationships of "active_session"
"""
type ActiveSession {
  """An array relationship"""
  activeUsers(
    """distinct select on columns"""
    distinctOn: [ActiveUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveUsersOrderBy!]
    """filter the rows returned"""
    where: ActiveUsersBoolExp
  ): [ActiveUsers!]!
  """An aggregate relationship"""
  activeUsersAggregate(
    """distinct select on columns"""
    distinctOn: [ActiveUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveUsersOrderBy!]
    """filter the rows returned"""
    where: ActiveUsersBoolExp
  ): ActiveUsersAggregate!
  endTime: timestamptz
  id: uuid
  """An object relationship"""
  room: Rooms
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""
aggregated selection of "active_session"
"""
type ActiveSessionAggregate {
  aggregate: ActiveSessionAggregateFields
  nodes: [ActiveSession!]!
}

"""
aggregate fields of "active_session"
"""
type ActiveSessionAggregateFields {
  count(columns: [ActiveSessionSelectColumn!], distinct: Boolean): Int!
  max: ActiveSessionMaxFields
  min: ActiveSessionMinFields
}

"""
Boolean expression to filter rows from the table "active_session". All fields are combined with a logical 'AND'.
"""
input ActiveSessionBoolExp {
  _and: [ActiveSessionBoolExp!]
  _not: ActiveSessionBoolExp
  _or: [ActiveSessionBoolExp!]
  activeUsers: ActiveUsersBoolExp
  activeUsersAggregate: ActiveUsersAggregateBoolExp
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  room: RoomsBoolExp
  roomId: UuidComparisonExp
  startTime: TimestamptzComparisonExp
  status: StringComparisonExp
}

"""
input type for inserting data into table "active_session"
"""
input ActiveSessionInsertInput {
  activeUsers: ActiveUsersArrRelInsertInput
  endTime: timestamptz
  id: uuid
  room: RoomsObjRelInsertInput
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""aggregate max on columns"""
type ActiveSessionMaxFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""aggregate min on columns"""
type ActiveSessionMinFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""
response of any mutation on the table "active_session"
"""
type ActiveSessionMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ActiveSession!]!
}

"""
input type for inserting object relation for remote table "active_session"
"""
input ActiveSessionObjRelInsertInput {
  data: ActiveSessionInsertInput!
}

"""Ordering options when selecting data from "active_session"."""
input ActiveSessionOrderBy {
  activeUsersAggregate: ActiveUsersAggregateOrderBy
  endTime: OrderBy
  id: OrderBy
  room: RoomsOrderBy
  roomId: OrderBy
  startTime: OrderBy
  status: OrderBy
}

"""
select columns of table "active_session"
"""
enum ActiveSessionSelectColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  roomId
  """column name"""
  startTime
  """column name"""
  status
}

"""
input type for updating data in table "active_session"
"""
input ActiveSessionSetInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""
Streaming cursor of the table "active_session"
"""
input ActiveSessionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ActiveSessionStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ActiveSessionStreamCursorValueInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

input ActiveSessionUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ActiveSessionSetInput
  """filter the rows which have to be updated"""
  where: ActiveSessionBoolExp!
}

"""
columns and relationships of "active_users"
"""
type ActiveUsers {
  endTime: timestamptz
  id: uuid
  """An object relationship"""
  room: Rooms
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  """An object relationship"""
  user: Users
  userId: uuid
}

"""
aggregated selection of "active_users"
"""
type ActiveUsersAggregate {
  aggregate: ActiveUsersAggregateFields
  nodes: [ActiveUsers!]!
}

input ActiveUsersAggregateBoolExp {
  count: activeUsersAggregateBoolExpCount
}

"""
aggregate fields of "active_users"
"""
type ActiveUsersAggregateFields {
  count(columns: [ActiveUsersSelectColumn!], distinct: Boolean): Int!
  max: ActiveUsersMaxFields
  min: ActiveUsersMinFields
}

"""
order by aggregate values of table "active_users"
"""
input ActiveUsersAggregateOrderBy {
  count: OrderBy
  max: ActiveUsersMaxOrderBy
  min: ActiveUsersMinOrderBy
}

"""
input type for inserting array relation for remote table "active_users"
"""
input ActiveUsersArrRelInsertInput {
  data: [ActiveUsersInsertInput!]!
}

"""
Boolean expression to filter rows from the table "active_users". All fields are combined with a logical 'AND'.
"""
input ActiveUsersBoolExp {
  _and: [ActiveUsersBoolExp!]
  _not: ActiveUsersBoolExp
  _or: [ActiveUsersBoolExp!]
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  room: RoomsBoolExp
  roomId: UuidComparisonExp
  sessionId: UuidComparisonExp
  startTime: TimestamptzComparisonExp
  status: StringComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
input type for inserting data into table "active_users"
"""
input ActiveUsersInsertInput {
  endTime: timestamptz
  id: uuid
  room: RoomsObjRelInsertInput
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type ActiveUsersMaxFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""
order by max() on columns of table "active_users"
"""
input ActiveUsersMaxOrderBy {
  endTime: OrderBy
  id: OrderBy
  roomId: OrderBy
  sessionId: OrderBy
  startTime: OrderBy
  status: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type ActiveUsersMinFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""
order by min() on columns of table "active_users"
"""
input ActiveUsersMinOrderBy {
  endTime: OrderBy
  id: OrderBy
  roomId: OrderBy
  sessionId: OrderBy
  startTime: OrderBy
  status: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "active_users"
"""
type ActiveUsersMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ActiveUsers!]!
}

"""
input type for inserting object relation for remote table "active_users"
"""
input ActiveUsersObjRelInsertInput {
  data: ActiveUsersInsertInput!
}

"""Ordering options when selecting data from "active_users"."""
input ActiveUsersOrderBy {
  endTime: OrderBy
  id: OrderBy
  room: RoomsOrderBy
  roomId: OrderBy
  sessionId: OrderBy
  startTime: OrderBy
  status: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""
select columns of table "active_users"
"""
enum ActiveUsersSelectColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  roomId
  """column name"""
  sessionId
  """column name"""
  startTime
  """column name"""
  status
  """column name"""
  userId
}

"""
input type for updating data in table "active_users"
"""
input ActiveUsersSetInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""
Streaming cursor of the table "active_users"
"""
input ActiveUsersStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ActiveUsersStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ActiveUsersStreamCursorValueInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

input ActiveUsersUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ActiveUsersSetInput
  """filter the rows which have to be updated"""
  where: ActiveUsersBoolExp!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type ClockInResponse {
  success: Boolean!
}

type ClockOutResponse {
  success: Boolean!
}

"""
columns and relationships of "clocked_in_users"
"""
type ClockedInUsers {
  clerkId: String
  email: String
  id: uuid
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""
aggregated selection of "clocked_in_users"
"""
type ClockedInUsersAggregate {
  aggregate: ClockedInUsersAggregateFields
  nodes: [ClockedInUsers!]!
}

"""
aggregate fields of "clocked_in_users"
"""
type ClockedInUsersAggregateFields {
  count(columns: [ClockedInUsersSelectColumn!], distinct: Boolean): Int!
  max: ClockedInUsersMaxFields
  min: ClockedInUsersMinFields
}

"""
Boolean expression to filter rows from the table "clocked_in_users". All fields are combined with a logical 'AND'.
"""
input ClockedInUsersBoolExp {
  _and: [ClockedInUsersBoolExp!]
  _not: ClockedInUsersBoolExp
  _or: [ClockedInUsersBoolExp!]
  clerkId: StringComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  role: StringComparisonExp
  shiftStatus: StringComparisonExp
  status: StringComparisonExp
}

"""
input type for inserting data into table "clocked_in_users"
"""
input ClockedInUsersInsertInput {
  clerkId: String
  email: String
  id: uuid
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""aggregate max on columns"""
type ClockedInUsersMaxFields {
  clerkId: String
  email: String
  id: uuid
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""aggregate min on columns"""
type ClockedInUsersMinFields {
  clerkId: String
  email: String
  id: uuid
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""
response of any mutation on the table "clocked_in_users"
"""
type ClockedInUsersMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [ClockedInUsers!]!
}

"""Ordering options when selecting data from "clocked_in_users"."""
input ClockedInUsersOrderBy {
  clerkId: OrderBy
  email: OrderBy
  id: OrderBy
  name: OrderBy
  role: OrderBy
  shiftStatus: OrderBy
  status: OrderBy
}

"""
select columns of table "clocked_in_users"
"""
enum ClockedInUsersSelectColumn {
  """column name"""
  clerkId
  """column name"""
  email
  """column name"""
  id
  """column name"""
  name
  """column name"""
  role
  """column name"""
  shiftStatus
  """column name"""
  status
}

"""
input type for updating data in table "clocked_in_users"
"""
input ClockedInUsersSetInput {
  clerkId: String
  email: String
  id: uuid
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""
Streaming cursor of the table "clocked_in_users"
"""
input ClockedInUsersStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ClockedInUsersStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ClockedInUsersStreamCursorValueInput {
  clerkId: String
  email: String
  id: uuid
  name: String
  role: String
  shiftStatus: String
  status: String
}

input ClockedInUsersUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: ClockedInUsersSetInput
  """filter the rows which have to be updated"""
  where: ClockedInUsersBoolExp!
}

"""
columns and relationships of "current_user_rotation"
"""
type CurrentUserRotation {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  """An object relationship"""
  user: Users
  userId: uuid
}

"""
aggregated selection of "current_user_rotation"
"""
type CurrentUserRotationAggregate {
  aggregate: CurrentUserRotationAggregateFields
  nodes: [CurrentUserRotation!]!
}

"""
aggregate fields of "current_user_rotation"
"""
type CurrentUserRotationAggregateFields {
  count(columns: [CurrentUserRotationSelectColumn!], distinct: Boolean): Int!
  max: CurrentUserRotationMaxFields
  min: CurrentUserRotationMinFields
}

"""
Boolean expression to filter rows from the table "current_user_rotation". All fields are combined with a logical 'AND'.
"""
input CurrentUserRotationBoolExp {
  _and: [CurrentUserRotationBoolExp!]
  _not: CurrentUserRotationBoolExp
  _or: [CurrentUserRotationBoolExp!]
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  rotationId: UuidComparisonExp
  startTime: TimestamptzComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
input type for inserting data into table "current_user_rotation"
"""
input CurrentUserRotationInsertInput {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type CurrentUserRotationMaxFields {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type CurrentUserRotationMinFields {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "current_user_rotation"
"""
type CurrentUserRotationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [CurrentUserRotation!]!
}

"""
input type for inserting object relation for remote table "current_user_rotation"
"""
input CurrentUserRotationObjRelInsertInput {
  data: CurrentUserRotationInsertInput!
}

"""Ordering options when selecting data from "current_user_rotation"."""
input CurrentUserRotationOrderBy {
  endTime: OrderBy
  id: OrderBy
  rotationId: OrderBy
  startTime: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""
select columns of table "current_user_rotation"
"""
enum CurrentUserRotationSelectColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  rotationId
  """column name"""
  startTime
  """column name"""
  userId
}

"""
input type for updating data in table "current_user_rotation"
"""
input CurrentUserRotationSetInput {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "current_user_rotation"
"""
input CurrentUserRotationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CurrentUserRotationStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CurrentUserRotationStreamCursorValueInput {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

input CurrentUserRotationUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: CurrentUserRotationSetInput
  """filter the rows which have to be updated"""
  where: CurrentUserRotationBoolExp!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC
  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC
  """in ascending order, nulls first"""
  ASC_NULLS_FIRST
  """in ascending order, nulls last"""
  ASC_NULLS_LAST
  """in descending order, nulls first"""
  DESC
  """in descending order, nulls first"""
  DESC_NULLS_FIRST
  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
columns and relationships of "rooms"
"""
type Rooms {
  """An object relationship"""
  activeSession: ActiveSession
  id: uuid!
  name: String!
  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinctOn: [SessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SessionsOrderBy!]
    """filter the rows returned"""
    where: SessionsBoolExp
  ): [Sessions!]!
  """An aggregate relationship"""
  sessionsAggregate(
    """distinct select on columns"""
    distinctOn: [SessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SessionsOrderBy!]
    """filter the rows returned"""
    where: SessionsBoolExp
  ): SessionsAggregate!
  status: String!
}

"""
aggregated selection of "rooms"
"""
type RoomsAggregate {
  aggregate: RoomsAggregateFields
  nodes: [Rooms!]!
}

"""
aggregate fields of "rooms"
"""
type RoomsAggregateFields {
  count(columns: [RoomsSelectColumn!], distinct: Boolean): Int!
  max: RoomsMaxFields
  min: RoomsMinFields
}

"""
Boolean expression to filter rows from the table "rooms". All fields are combined with a logical 'AND'.
"""
input RoomsBoolExp {
  _and: [RoomsBoolExp!]
  _not: RoomsBoolExp
  _or: [RoomsBoolExp!]
  activeSession: ActiveSessionBoolExp
  id: UuidComparisonExp
  name: StringComparisonExp
  sessions: SessionsBoolExp
  sessionsAggregate: SessionsAggregateBoolExp
  status: StringComparisonExp
}

"""
unique or primary key constraints on table "rooms"
"""
enum RoomsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  rooms_pkey
}

"""
input type for inserting data into table "rooms"
"""
input RoomsInsertInput {
  activeSession: ActiveSessionObjRelInsertInput
  id: uuid
  name: String
  sessions: SessionsArrRelInsertInput
  status: String
}

"""aggregate max on columns"""
type RoomsMaxFields {
  id: uuid
  name: String
  status: String
}

"""aggregate min on columns"""
type RoomsMinFields {
  id: uuid
  name: String
  status: String
}

"""
response of any mutation on the table "rooms"
"""
type RoomsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Rooms!]!
}

"""
input type for inserting object relation for remote table "rooms"
"""
input RoomsObjRelInsertInput {
  data: RoomsInsertInput!
  """upsert condition"""
  onConflict: RoomsOnConflict
}

"""
on_conflict condition type for table "rooms"
"""
input RoomsOnConflict {
  constraint: RoomsConstraint!
  updateColumns: [RoomsUpdateColumn!]! = []
  where: RoomsBoolExp
}

"""Ordering options when selecting data from "rooms"."""
input RoomsOrderBy {
  activeSession: ActiveSessionOrderBy
  id: OrderBy
  name: OrderBy
  sessionsAggregate: SessionsAggregateOrderBy
  status: OrderBy
}

"""primary key columns input for table: rooms"""
input RoomsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "rooms"
"""
enum RoomsSelectColumn {
  """column name"""
  id
  """column name"""
  name
  """column name"""
  status
}

"""
input type for updating data in table "rooms"
"""
input RoomsSetInput {
  id: uuid
  name: String
  status: String
}

"""
Streaming cursor of the table "rooms"
"""
input RoomsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RoomsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RoomsStreamCursorValueInput {
  id: uuid
  name: String
  status: String
}

"""
update columns of table "rooms"
"""
enum RoomsUpdateColumn {
  """column name"""
  id
  """column name"""
  name
  """column name"""
  status
}

input RoomsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: RoomsSetInput
  """filter the rows which have to be updated"""
  where: RoomsBoolExp!
}

"""
columns and relationships of "rotation"
"""
type Rotation {
  """An object relationship"""
  currentUserRotation: CurrentUserRotation
  id: uuid!
  index: Int!
  isActive: Boolean!
  name: String!
  type: String!
  userId: uuid
}

"""
aggregated selection of "rotation"
"""
type RotationAggregate {
  aggregate: RotationAggregateFields
  nodes: [Rotation!]!
}

"""
aggregate fields of "rotation"
"""
type RotationAggregateFields {
  avg: RotationAvgFields
  count(columns: [RotationSelectColumn!], distinct: Boolean): Int!
  max: RotationMaxFields
  min: RotationMinFields
  stddev: RotationStddevFields
  stddevPop: RotationStddevPopFields
  stddevSamp: RotationStddevSampFields
  sum: RotationSumFields
  varPop: RotationVarPopFields
  varSamp: RotationVarSampFields
  variance: RotationVarianceFields
}

"""aggregate avg on columns"""
type RotationAvgFields {
  index: Float
}

"""
Boolean expression to filter rows from the table "rotation". All fields are combined with a logical 'AND'.
"""
input RotationBoolExp {
  _and: [RotationBoolExp!]
  _not: RotationBoolExp
  _or: [RotationBoolExp!]
  currentUserRotation: CurrentUserRotationBoolExp
  id: UuidComparisonExp
  index: IntComparisonExp
  isActive: BooleanComparisonExp
  name: StringComparisonExp
  type: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "rotation"
"""
enum RotationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  rotation_pkey
}

"""
input type for incrementing numeric columns in table "rotation"
"""
input RotationIncInput {
  index: Int
}

"""
input type for inserting data into table "rotation"
"""
input RotationInsertInput {
  currentUserRotation: CurrentUserRotationObjRelInsertInput
  id: uuid
  index: Int
  isActive: Boolean
  name: String
  type: String
  userId: uuid
}

"""aggregate max on columns"""
type RotationMaxFields {
  id: uuid
  index: Int
  name: String
  type: String
  userId: uuid
}

"""aggregate min on columns"""
type RotationMinFields {
  id: uuid
  index: Int
  name: String
  type: String
  userId: uuid
}

"""
response of any mutation on the table "rotation"
"""
type RotationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Rotation!]!
}

"""
on_conflict condition type for table "rotation"
"""
input RotationOnConflict {
  constraint: RotationConstraint!
  updateColumns: [RotationUpdateColumn!]! = []
  where: RotationBoolExp
}

"""Ordering options when selecting data from "rotation"."""
input RotationOrderBy {
  currentUserRotation: CurrentUserRotationOrderBy
  id: OrderBy
  index: OrderBy
  isActive: OrderBy
  name: OrderBy
  type: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: rotation"""
input RotationPkColumnsInput {
  id: uuid!
}

"""
select columns of table "rotation"
"""
enum RotationSelectColumn {
  """column name"""
  id
  """column name"""
  index
  """column name"""
  isActive
  """column name"""
  name
  """column name"""
  type
  """column name"""
  userId
}

"""
input type for updating data in table "rotation"
"""
input RotationSetInput {
  id: uuid
  index: Int
  isActive: Boolean
  name: String
  type: String
  userId: uuid
}

"""aggregate stddev on columns"""
type RotationStddevFields {
  index: Float
}

"""aggregate stddevPop on columns"""
type RotationStddevPopFields {
  index: Float
}

"""aggregate stddevSamp on columns"""
type RotationStddevSampFields {
  index: Float
}

"""
Streaming cursor of the table "rotation"
"""
input RotationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: RotationStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input RotationStreamCursorValueInput {
  id: uuid
  index: Int
  isActive: Boolean
  name: String
  type: String
  userId: uuid
}

"""aggregate sum on columns"""
type RotationSumFields {
  index: Int
}

"""
update columns of table "rotation"
"""
enum RotationUpdateColumn {
  """column name"""
  id
  """column name"""
  index
  """column name"""
  isActive
  """column name"""
  name
  """column name"""
  type
  """column name"""
  userId
}

input RotationUpdates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: RotationIncInput
  """sets the columns of the filtered rows to the given values"""
  _set: RotationSetInput
  """filter the rows which have to be updated"""
  where: RotationBoolExp!
}

"""aggregate varPop on columns"""
type RotationVarPopFields {
  index: Float
}

"""aggregate varSamp on columns"""
type RotationVarSampFields {
  index: Float
}

"""aggregate variance on columns"""
type RotationVarianceFields {
  index: Float
}

"""
columns and relationships of "sessions"
"""
type Sessions {
  endTime: timestamptz
  id: uuid!
  """An object relationship"""
  room: Rooms!
  roomId: uuid!
  startTime: timestamptz!
  status: String!
  """An array relationship"""
  userSessions(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """An aggregate relationship"""
  userSessionsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): UserSessionsAggregate!
}

"""
aggregated selection of "sessions"
"""
type SessionsAggregate {
  aggregate: SessionsAggregateFields
  nodes: [Sessions!]!
}

input SessionsAggregateBoolExp {
  count: sessionsAggregateBoolExpCount
}

"""
aggregate fields of "sessions"
"""
type SessionsAggregateFields {
  count(columns: [SessionsSelectColumn!], distinct: Boolean): Int!
  max: SessionsMaxFields
  min: SessionsMinFields
}

"""
order by aggregate values of table "sessions"
"""
input SessionsAggregateOrderBy {
  count: OrderBy
  max: SessionsMaxOrderBy
  min: SessionsMinOrderBy
}

"""
input type for inserting array relation for remote table "sessions"
"""
input SessionsArrRelInsertInput {
  data: [SessionsInsertInput!]!
  """upsert condition"""
  onConflict: SessionsOnConflict
}

"""
Boolean expression to filter rows from the table "sessions". All fields are combined with a logical 'AND'.
"""
input SessionsBoolExp {
  _and: [SessionsBoolExp!]
  _not: SessionsBoolExp
  _or: [SessionsBoolExp!]
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  room: RoomsBoolExp
  roomId: UuidComparisonExp
  startTime: TimestamptzComparisonExp
  status: StringComparisonExp
  userSessions: UserSessionsBoolExp
  userSessionsAggregate: UserSessionsAggregateBoolExp
}

"""
unique or primary key constraints on table "sessions"
"""
enum SessionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  sessions_pkey
}

"""
input type for inserting data into table "sessions"
"""
input SessionsInsertInput {
  endTime: timestamptz
  id: uuid
  room: RoomsObjRelInsertInput
  roomId: uuid
  startTime: timestamptz
  status: String
  userSessions: UserSessionsArrRelInsertInput
}

"""aggregate max on columns"""
type SessionsMaxFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""
order by max() on columns of table "sessions"
"""
input SessionsMaxOrderBy {
  endTime: OrderBy
  id: OrderBy
  roomId: OrderBy
  startTime: OrderBy
  status: OrderBy
}

"""aggregate min on columns"""
type SessionsMinFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""
order by min() on columns of table "sessions"
"""
input SessionsMinOrderBy {
  endTime: OrderBy
  id: OrderBy
  roomId: OrderBy
  startTime: OrderBy
  status: OrderBy
}

"""
response of any mutation on the table "sessions"
"""
type SessionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Sessions!]!
}

"""
input type for inserting object relation for remote table "sessions"
"""
input SessionsObjRelInsertInput {
  data: SessionsInsertInput!
  """upsert condition"""
  onConflict: SessionsOnConflict
}

"""
on_conflict condition type for table "sessions"
"""
input SessionsOnConflict {
  constraint: SessionsConstraint!
  updateColumns: [SessionsUpdateColumn!]! = []
  where: SessionsBoolExp
}

"""Ordering options when selecting data from "sessions"."""
input SessionsOrderBy {
  endTime: OrderBy
  id: OrderBy
  room: RoomsOrderBy
  roomId: OrderBy
  startTime: OrderBy
  status: OrderBy
  userSessionsAggregate: UserSessionsAggregateOrderBy
}

"""primary key columns input for table: sessions"""
input SessionsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "sessions"
"""
enum SessionsSelectColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  roomId
  """column name"""
  startTime
  """column name"""
  status
}

"""
input type for updating data in table "sessions"
"""
input SessionsSetInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""
Streaming cursor of the table "sessions"
"""
input SessionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: SessionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input SessionsStreamCursorValueInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  startTime: timestamptz
  status: String
}

"""
update columns of table "sessions"
"""
enum SessionsUpdateColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  roomId
  """column name"""
  startTime
  """column name"""
  status
}

input SessionsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: SessionsSetInput
  """filter the rows which have to be updated"""
  where: SessionsBoolExp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String
  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean
  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """does the column NOT match the given pattern"""
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_logins"
"""
type UserLogins {
  endTime: timestamptz
  id: uuid!
  startTime: timestamptz!
  userId: uuid!
}

"""
aggregated selection of "user_logins"
"""
type UserLoginsAggregate {
  aggregate: UserLoginsAggregateFields
  nodes: [UserLogins!]!
}

"""
aggregate fields of "user_logins"
"""
type UserLoginsAggregateFields {
  count(columns: [UserLoginsSelectColumn!], distinct: Boolean): Int!
  max: UserLoginsMaxFields
  min: UserLoginsMinFields
}

"""
Boolean expression to filter rows from the table "user_logins". All fields are combined with a logical 'AND'.
"""
input UserLoginsBoolExp {
  _and: [UserLoginsBoolExp!]
  _not: UserLoginsBoolExp
  _or: [UserLoginsBoolExp!]
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  startTime: TimestamptzComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_logins"
"""
enum UserLoginsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_logins_pkey
}

"""
input type for inserting data into table "user_logins"
"""
input UserLoginsInsertInput {
  endTime: timestamptz
  id: uuid
  startTime: timestamptz
  userId: uuid
}

"""aggregate max on columns"""
type UserLoginsMaxFields {
  endTime: timestamptz
  id: uuid
  startTime: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type UserLoginsMinFields {
  endTime: timestamptz
  id: uuid
  startTime: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "user_logins"
"""
type UserLoginsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserLogins!]!
}

"""
on_conflict condition type for table "user_logins"
"""
input UserLoginsOnConflict {
  constraint: UserLoginsConstraint!
  updateColumns: [UserLoginsUpdateColumn!]! = []
  where: UserLoginsBoolExp
}

"""Ordering options when selecting data from "user_logins"."""
input UserLoginsOrderBy {
  endTime: OrderBy
  id: OrderBy
  startTime: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_logins"""
input UserLoginsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user_logins"
"""
enum UserLoginsSelectColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  startTime
  """column name"""
  userId
}

"""
input type for updating data in table "user_logins"
"""
input UserLoginsSetInput {
  endTime: timestamptz
  id: uuid
  startTime: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "user_logins"
"""
input UserLoginsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserLoginsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserLoginsStreamCursorValueInput {
  endTime: timestamptz
  id: uuid
  startTime: timestamptz
  userId: uuid
}

"""
update columns of table "user_logins"
"""
enum UserLoginsUpdateColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  startTime
  """column name"""
  userId
}

input UserLoginsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserLoginsSetInput
  """filter the rows which have to be updated"""
  where: UserLoginsBoolExp!
}

"""
columns and relationships of "user_rotation"
"""
type UserRotation {
  endTime: timestamptz
  id: uuid!
  rotationId: uuid!
  startTime: timestamptz!
  """An object relationship"""
  user: Users
  userId: uuid!
}

"""
aggregated selection of "user_rotation"
"""
type UserRotationAggregate {
  aggregate: UserRotationAggregateFields
  nodes: [UserRotation!]!
}

"""
aggregate fields of "user_rotation"
"""
type UserRotationAggregateFields {
  count(columns: [UserRotationSelectColumn!], distinct: Boolean): Int!
  max: UserRotationMaxFields
  min: UserRotationMinFields
}

"""
Boolean expression to filter rows from the table "user_rotation". All fields are combined with a logical 'AND'.
"""
input UserRotationBoolExp {
  _and: [UserRotationBoolExp!]
  _not: UserRotationBoolExp
  _or: [UserRotationBoolExp!]
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  rotationId: UuidComparisonExp
  startTime: TimestamptzComparisonExp
  user: UsersBoolExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_rotation"
"""
enum UserRotationConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_rotation_pkey
}

"""
input type for inserting data into table "user_rotation"
"""
input UserRotationInsertInput {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  user: UsersObjRelInsertInput
  userId: uuid
}

"""aggregate max on columns"""
type UserRotationMaxFields {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

"""aggregate min on columns"""
type UserRotationMinFields {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

"""
response of any mutation on the table "user_rotation"
"""
type UserRotationMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserRotation!]!
}

"""
on_conflict condition type for table "user_rotation"
"""
input UserRotationOnConflict {
  constraint: UserRotationConstraint!
  updateColumns: [UserRotationUpdateColumn!]! = []
  where: UserRotationBoolExp
}

"""Ordering options when selecting data from "user_rotation"."""
input UserRotationOrderBy {
  endTime: OrderBy
  id: OrderBy
  rotationId: OrderBy
  startTime: OrderBy
  user: UsersOrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_rotation"""
input UserRotationPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user_rotation"
"""
enum UserRotationSelectColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  rotationId
  """column name"""
  startTime
  """column name"""
  userId
}

"""
input type for updating data in table "user_rotation"
"""
input UserRotationSetInput {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "user_rotation"
"""
input UserRotationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserRotationStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserRotationStreamCursorValueInput {
  endTime: timestamptz
  id: uuid
  rotationId: uuid
  startTime: timestamptz
  userId: uuid
}

"""
update columns of table "user_rotation"
"""
enum UserRotationUpdateColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  rotationId
  """column name"""
  startTime
  """column name"""
  userId
}

input UserRotationUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserRotationSetInput
  """filter the rows which have to be updated"""
  where: UserRotationBoolExp!
}

"""
columns and relationships of "user_sessions"
"""
type UserSessions {
  endTime: timestamptz
  id: uuid!
  roomId: uuid!
  """An object relationship"""
  session: Sessions
  sessionId: uuid!
  startTime: timestamptz!
  status: String!
  userId: uuid!
}

"""
aggregated selection of "user_sessions"
"""
type UserSessionsAggregate {
  aggregate: UserSessionsAggregateFields
  nodes: [UserSessions!]!
}

input UserSessionsAggregateBoolExp {
  count: userSessionsAggregateBoolExpCount
}

"""
aggregate fields of "user_sessions"
"""
type UserSessionsAggregateFields {
  count(columns: [UserSessionsSelectColumn!], distinct: Boolean): Int!
  max: UserSessionsMaxFields
  min: UserSessionsMinFields
}

"""
order by aggregate values of table "user_sessions"
"""
input UserSessionsAggregateOrderBy {
  count: OrderBy
  max: UserSessionsMaxOrderBy
  min: UserSessionsMinOrderBy
}

"""
input type for inserting array relation for remote table "user_sessions"
"""
input UserSessionsArrRelInsertInput {
  data: [UserSessionsInsertInput!]!
  """upsert condition"""
  onConflict: UserSessionsOnConflict
}

"""
Boolean expression to filter rows from the table "user_sessions". All fields are combined with a logical 'AND'.
"""
input UserSessionsBoolExp {
  _and: [UserSessionsBoolExp!]
  _not: UserSessionsBoolExp
  _or: [UserSessionsBoolExp!]
  endTime: TimestamptzComparisonExp
  id: UuidComparisonExp
  roomId: UuidComparisonExp
  session: SessionsBoolExp
  sessionId: UuidComparisonExp
  startTime: TimestamptzComparisonExp
  status: StringComparisonExp
  userId: UuidComparisonExp
}

"""
unique or primary key constraints on table "user_sessions"
"""
enum UserSessionsConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_sessions_pkey
}

"""
input type for inserting data into table "user_sessions"
"""
input UserSessionsInsertInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  session: SessionsObjRelInsertInput
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""aggregate max on columns"""
type UserSessionsMaxFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""
order by max() on columns of table "user_sessions"
"""
input UserSessionsMaxOrderBy {
  endTime: OrderBy
  id: OrderBy
  roomId: OrderBy
  sessionId: OrderBy
  startTime: OrderBy
  status: OrderBy
  userId: OrderBy
}

"""aggregate min on columns"""
type UserSessionsMinFields {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""
order by min() on columns of table "user_sessions"
"""
input UserSessionsMinOrderBy {
  endTime: OrderBy
  id: OrderBy
  roomId: OrderBy
  sessionId: OrderBy
  startTime: OrderBy
  status: OrderBy
  userId: OrderBy
}

"""
response of any mutation on the table "user_sessions"
"""
type UserSessionsMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [UserSessions!]!
}

"""
on_conflict condition type for table "user_sessions"
"""
input UserSessionsOnConflict {
  constraint: UserSessionsConstraint!
  updateColumns: [UserSessionsUpdateColumn!]! = []
  where: UserSessionsBoolExp
}

"""Ordering options when selecting data from "user_sessions"."""
input UserSessionsOrderBy {
  endTime: OrderBy
  id: OrderBy
  roomId: OrderBy
  session: SessionsOrderBy
  sessionId: OrderBy
  startTime: OrderBy
  status: OrderBy
  userId: OrderBy
}

"""primary key columns input for table: user_sessions"""
input UserSessionsPkColumnsInput {
  id: uuid!
}

"""
select columns of table "user_sessions"
"""
enum UserSessionsSelectColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  roomId
  """column name"""
  sessionId
  """column name"""
  startTime
  """column name"""
  status
  """column name"""
  userId
}

"""
input type for updating data in table "user_sessions"
"""
input UserSessionsSetInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""
Streaming cursor of the table "user_sessions"
"""
input UserSessionsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserSessionsStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserSessionsStreamCursorValueInput {
  endTime: timestamptz
  id: uuid
  roomId: uuid
  sessionId: uuid
  startTime: timestamptz
  status: String
  userId: uuid
}

"""
update columns of table "user_sessions"
"""
enum UserSessionsUpdateColumn {
  """column name"""
  endTime
  """column name"""
  id
  """column name"""
  roomId
  """column name"""
  sessionId
  """column name"""
  startTime
  """column name"""
  status
  """column name"""
  userId
}

input UserSessionsUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UserSessionsSetInput
  """filter the rows which have to be updated"""
  where: UserSessionsBoolExp!
}

"""
columns and relationships of "users"
"""
type Users {
  """An object relationship"""
  activeSession: ActiveUsers
  clerkId: String
  email: String!
  id: uuid!
  loginStatus: String!
  name: String!
  role: String!
  shiftStatus: String!
  status: String!
}

"""
aggregated selection of "users"
"""
type UsersAggregate {
  aggregate: UsersAggregateFields
  nodes: [Users!]!
}

"""
aggregate fields of "users"
"""
type UsersAggregateFields {
  count(columns: [UsersSelectColumn!], distinct: Boolean): Int!
  max: UsersMaxFields
  min: UsersMinFields
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input UsersBoolExp {
  _and: [UsersBoolExp!]
  _not: UsersBoolExp
  _or: [UsersBoolExp!]
  activeSession: ActiveUsersBoolExp
  clerkId: StringComparisonExp
  email: StringComparisonExp
  id: UuidComparisonExp
  loginStatus: StringComparisonExp
  name: StringComparisonExp
  role: StringComparisonExp
  shiftStatus: StringComparisonExp
  status: StringComparisonExp
}

"""
unique or primary key constraints on table "users"
"""
enum UsersConstraint {
  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input UsersInsertInput {
  activeSession: ActiveUsersObjRelInsertInput
  clerkId: String
  email: String
  id: uuid
  loginStatus: String
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""aggregate max on columns"""
type UsersMaxFields {
  clerkId: String
  email: String
  id: uuid
  loginStatus: String
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""aggregate min on columns"""
type UsersMinFields {
  clerkId: String
  email: String
  id: uuid
  loginStatus: String
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""
response of any mutation on the table "users"
"""
type UsersMutationResponse {
  """number of rows affected by the mutation"""
  affectedRows: Int!
  """data from the rows affected by the mutation"""
  returning: [Users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input UsersObjRelInsertInput {
  data: UsersInsertInput!
  """upsert condition"""
  onConflict: UsersOnConflict
}

"""
on_conflict condition type for table "users"
"""
input UsersOnConflict {
  constraint: UsersConstraint!
  updateColumns: [UsersUpdateColumn!]! = []
  where: UsersBoolExp
}

"""Ordering options when selecting data from "users"."""
input UsersOrderBy {
  activeSession: ActiveUsersOrderBy
  clerkId: OrderBy
  email: OrderBy
  id: OrderBy
  loginStatus: OrderBy
  name: OrderBy
  role: OrderBy
  shiftStatus: OrderBy
  status: OrderBy
}

"""primary key columns input for table: users"""
input UsersPkColumnsInput {
  id: uuid!
}

"""
select columns of table "users"
"""
enum UsersSelectColumn {
  """column name"""
  clerkId
  """column name"""
  email
  """column name"""
  id
  """column name"""
  loginStatus
  """column name"""
  name
  """column name"""
  role
  """column name"""
  shiftStatus
  """column name"""
  status
}

"""
input type for updating data in table "users"
"""
input UsersSetInput {
  clerkId: String
  email: String
  id: uuid
  loginStatus: String
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""
Streaming cursor of the table "users"
"""
input UsersStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UsersStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UsersStreamCursorValueInput {
  clerkId: String
  email: String
  id: uuid
  loginStatus: String
  name: String
  role: String
  shiftStatus: String
  status: String
}

"""
update columns of table "users"
"""
enum UsersUpdateColumn {
  """column name"""
  clerkId
  """column name"""
  email
  """column name"""
  id
  """column name"""
  loginStatus
  """column name"""
  name
  """column name"""
  role
  """column name"""
  shiftStatus
  """column name"""
  status
}

input UsersUpdates {
  """sets the columns of the filtered rows to the given values"""
  _set: UsersSetInput
  """filter the rows which have to be updated"""
  where: UsersBoolExp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input activeUsersAggregateBoolExpCount {
  arguments: [ActiveUsersSelectColumn!]
  distinct: Boolean
  filter: ActiveUsersBoolExp
  predicate: IntComparisonExp!
}

"""mutation root"""
type mutation_root {
  """Assign dancer to rotation slot on clock in"""
  clockIn: ClockInResponse!
  clockOut: ClockOutResponse!
  """
  delete data from the table: "active_rotation"
  """
  deleteActiveRotation(
    """filter the rows which have to be deleted"""
    where: ActiveRotationBoolExp!
  ): ActiveRotationMutationResponse
  """
  delete data from the table: "active_session"
  """
  deleteActiveSession(
    """filter the rows which have to be deleted"""
    where: ActiveSessionBoolExp!
  ): ActiveSessionMutationResponse
  """
  delete data from the table: "active_users"
  """
  deleteActiveUsers(
    """filter the rows which have to be deleted"""
    where: ActiveUsersBoolExp!
  ): ActiveUsersMutationResponse
  """
  delete data from the table: "clocked_in_users"
  """
  deleteClockedInUsers(
    """filter the rows which have to be deleted"""
    where: ClockedInUsersBoolExp!
  ): ClockedInUsersMutationResponse
  """
  delete data from the table: "current_user_rotation"
  """
  deleteCurrentUserRotation(
    """filter the rows which have to be deleted"""
    where: CurrentUserRotationBoolExp!
  ): CurrentUserRotationMutationResponse
  """
  delete data from the table: "rooms"
  """
  deleteRooms(
    """filter the rows which have to be deleted"""
    where: RoomsBoolExp!
  ): RoomsMutationResponse
  """
  delete single row from the table: "rooms"
  """
  deleteRoomsByPk(id: uuid!): Rooms
  """
  delete data from the table: "rotation"
  """
  deleteRotation(
    """filter the rows which have to be deleted"""
    where: RotationBoolExp!
  ): RotationMutationResponse
  """
  delete single row from the table: "rotation"
  """
  deleteRotationByPk(id: uuid!): Rotation
  """
  delete data from the table: "sessions"
  """
  deleteSessions(
    """filter the rows which have to be deleted"""
    where: SessionsBoolExp!
  ): SessionsMutationResponse
  """
  delete single row from the table: "sessions"
  """
  deleteSessionsByPk(id: uuid!): Sessions
  """
  delete data from the table: "user_logins"
  """
  deleteUserLogins(
    """filter the rows which have to be deleted"""
    where: UserLoginsBoolExp!
  ): UserLoginsMutationResponse
  """
  delete single row from the table: "user_logins"
  """
  deleteUserLoginsByPk(id: uuid!): UserLogins
  """
  delete data from the table: "user_rotation"
  """
  deleteUserRotation(
    """filter the rows which have to be deleted"""
    where: UserRotationBoolExp!
  ): UserRotationMutationResponse
  """
  delete single row from the table: "user_rotation"
  """
  deleteUserRotationByPk(id: uuid!): UserRotation
  """
  delete data from the table: "user_sessions"
  """
  deleteUserSessions(
    """filter the rows which have to be deleted"""
    where: UserSessionsBoolExp!
  ): UserSessionsMutationResponse
  """
  delete single row from the table: "user_sessions"
  """
  deleteUserSessionsByPk(id: uuid!): UserSessions
  """
  delete data from the table: "users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: UsersBoolExp!
  ): UsersMutationResponse
  """
  delete single row from the table: "users"
  """
  deleteUsersByPk(id: uuid!): Users
  """
  insert data into the table: "active_rotation"
  """
  insertActiveRotation(
    """the rows to be inserted"""
    objects: [ActiveRotationInsertInput!]!
  ): ActiveRotationMutationResponse
  """
  insert a single row into the table: "active_rotation"
  """
  insertActiveRotationOne(
    """the row to be inserted"""
    object: ActiveRotationInsertInput!
  ): ActiveRotation
  """
  insert data into the table: "active_session"
  """
  insertActiveSession(
    """the rows to be inserted"""
    objects: [ActiveSessionInsertInput!]!
  ): ActiveSessionMutationResponse
  """
  insert a single row into the table: "active_session"
  """
  insertActiveSessionOne(
    """the row to be inserted"""
    object: ActiveSessionInsertInput!
  ): ActiveSession
  """
  insert data into the table: "active_users"
  """
  insertActiveUsers(
    """the rows to be inserted"""
    objects: [ActiveUsersInsertInput!]!
  ): ActiveUsersMutationResponse
  """
  insert a single row into the table: "active_users"
  """
  insertActiveUsersOne(
    """the row to be inserted"""
    object: ActiveUsersInsertInput!
  ): ActiveUsers
  """
  insert data into the table: "clocked_in_users"
  """
  insertClockedInUsers(
    """the rows to be inserted"""
    objects: [ClockedInUsersInsertInput!]!
  ): ClockedInUsersMutationResponse
  """
  insert a single row into the table: "clocked_in_users"
  """
  insertClockedInUsersOne(
    """the row to be inserted"""
    object: ClockedInUsersInsertInput!
  ): ClockedInUsers
  """
  insert data into the table: "current_user_rotation"
  """
  insertCurrentUserRotation(
    """the rows to be inserted"""
    objects: [CurrentUserRotationInsertInput!]!
  ): CurrentUserRotationMutationResponse
  """
  insert a single row into the table: "current_user_rotation"
  """
  insertCurrentUserRotationOne(
    """the row to be inserted"""
    object: CurrentUserRotationInsertInput!
  ): CurrentUserRotation
  """
  insert data into the table: "rooms"
  """
  insertRooms(
    """the rows to be inserted"""
    objects: [RoomsInsertInput!]!
    """upsert condition"""
    onConflict: RoomsOnConflict
  ): RoomsMutationResponse
  """
  insert a single row into the table: "rooms"
  """
  insertRoomsOne(
    """the row to be inserted"""
    object: RoomsInsertInput!
    """upsert condition"""
    onConflict: RoomsOnConflict
  ): Rooms
  """
  insert data into the table: "rotation"
  """
  insertRotation(
    """the rows to be inserted"""
    objects: [RotationInsertInput!]!
    """upsert condition"""
    onConflict: RotationOnConflict
  ): RotationMutationResponse
  """
  insert a single row into the table: "rotation"
  """
  insertRotationOne(
    """the row to be inserted"""
    object: RotationInsertInput!
    """upsert condition"""
    onConflict: RotationOnConflict
  ): Rotation
  """
  insert data into the table: "sessions"
  """
  insertSessions(
    """the rows to be inserted"""
    objects: [SessionsInsertInput!]!
    """upsert condition"""
    onConflict: SessionsOnConflict
  ): SessionsMutationResponse
  """
  insert a single row into the table: "sessions"
  """
  insertSessionsOne(
    """the row to be inserted"""
    object: SessionsInsertInput!
    """upsert condition"""
    onConflict: SessionsOnConflict
  ): Sessions
  """
  insert data into the table: "user_logins"
  """
  insertUserLogins(
    """the rows to be inserted"""
    objects: [UserLoginsInsertInput!]!
    """upsert condition"""
    onConflict: UserLoginsOnConflict
  ): UserLoginsMutationResponse
  """
  insert a single row into the table: "user_logins"
  """
  insertUserLoginsOne(
    """the row to be inserted"""
    object: UserLoginsInsertInput!
    """upsert condition"""
    onConflict: UserLoginsOnConflict
  ): UserLogins
  """
  insert data into the table: "user_rotation"
  """
  insertUserRotation(
    """the rows to be inserted"""
    objects: [UserRotationInsertInput!]!
    """upsert condition"""
    onConflict: UserRotationOnConflict
  ): UserRotationMutationResponse
  """
  insert a single row into the table: "user_rotation"
  """
  insertUserRotationOne(
    """the row to be inserted"""
    object: UserRotationInsertInput!
    """upsert condition"""
    onConflict: UserRotationOnConflict
  ): UserRotation
  """
  insert data into the table: "user_sessions"
  """
  insertUserSessions(
    """the rows to be inserted"""
    objects: [UserSessionsInsertInput!]!
    """upsert condition"""
    onConflict: UserSessionsOnConflict
  ): UserSessionsMutationResponse
  """
  insert a single row into the table: "user_sessions"
  """
  insertUserSessionsOne(
    """the row to be inserted"""
    object: UserSessionsInsertInput!
    """upsert condition"""
    onConflict: UserSessionsOnConflict
  ): UserSessions
  """
  insert data into the table: "users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [UsersInsertInput!]!
    """upsert condition"""
    onConflict: UsersOnConflict
  ): UsersMutationResponse
  """
  insert a single row into the table: "users"
  """
  insertUsersOne(
    """the row to be inserted"""
    object: UsersInsertInput!
    """upsert condition"""
    onConflict: UsersOnConflict
  ): Users
  """
  update data of the table: "active_rotation"
  """
  updateActiveRotation(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ActiveRotationIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: ActiveRotationSetInput
    """filter the rows which have to be updated"""
    where: ActiveRotationBoolExp!
  ): ActiveRotationMutationResponse
  """
  update multiples rows of table: "active_rotation"
  """
  updateActiveRotationMany(
    """updates to execute, in order"""
    updates: [ActiveRotationUpdates!]!
  ): [ActiveRotationMutationResponse]
  """
  update data of the table: "active_session"
  """
  updateActiveSession(
    """sets the columns of the filtered rows to the given values"""
    _set: ActiveSessionSetInput
    """filter the rows which have to be updated"""
    where: ActiveSessionBoolExp!
  ): ActiveSessionMutationResponse
  """
  update multiples rows of table: "active_session"
  """
  updateActiveSessionMany(
    """updates to execute, in order"""
    updates: [ActiveSessionUpdates!]!
  ): [ActiveSessionMutationResponse]
  """
  update data of the table: "active_users"
  """
  updateActiveUsers(
    """sets the columns of the filtered rows to the given values"""
    _set: ActiveUsersSetInput
    """filter the rows which have to be updated"""
    where: ActiveUsersBoolExp!
  ): ActiveUsersMutationResponse
  """
  update multiples rows of table: "active_users"
  """
  updateActiveUsersMany(
    """updates to execute, in order"""
    updates: [ActiveUsersUpdates!]!
  ): [ActiveUsersMutationResponse]
  """
  update data of the table: "clocked_in_users"
  """
  updateClockedInUsers(
    """sets the columns of the filtered rows to the given values"""
    _set: ClockedInUsersSetInput
    """filter the rows which have to be updated"""
    where: ClockedInUsersBoolExp!
  ): ClockedInUsersMutationResponse
  """
  update multiples rows of table: "clocked_in_users"
  """
  updateClockedInUsersMany(
    """updates to execute, in order"""
    updates: [ClockedInUsersUpdates!]!
  ): [ClockedInUsersMutationResponse]
  """
  update data of the table: "current_user_rotation"
  """
  updateCurrentUserRotation(
    """sets the columns of the filtered rows to the given values"""
    _set: CurrentUserRotationSetInput
    """filter the rows which have to be updated"""
    where: CurrentUserRotationBoolExp!
  ): CurrentUserRotationMutationResponse
  """
  update multiples rows of table: "current_user_rotation"
  """
  updateCurrentUserRotationMany(
    """updates to execute, in order"""
    updates: [CurrentUserRotationUpdates!]!
  ): [CurrentUserRotationMutationResponse]
  """
  update data of the table: "rooms"
  """
  updateRooms(
    """sets the columns of the filtered rows to the given values"""
    _set: RoomsSetInput
    """filter the rows which have to be updated"""
    where: RoomsBoolExp!
  ): RoomsMutationResponse
  """
  update single row of the table: "rooms"
  """
  updateRoomsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: RoomsSetInput
    pkColumns: RoomsPkColumnsInput!
  ): Rooms
  """
  update multiples rows of table: "rooms"
  """
  updateRoomsMany(
    """updates to execute, in order"""
    updates: [RoomsUpdates!]!
  ): [RoomsMutationResponse]
  """
  update data of the table: "rotation"
  """
  updateRotation(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RotationIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: RotationSetInput
    """filter the rows which have to be updated"""
    where: RotationBoolExp!
  ): RotationMutationResponse
  """
  update single row of the table: "rotation"
  """
  updateRotationByPk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: RotationIncInput
    """sets the columns of the filtered rows to the given values"""
    _set: RotationSetInput
    pkColumns: RotationPkColumnsInput!
  ): Rotation
  """
  update multiples rows of table: "rotation"
  """
  updateRotationMany(
    """updates to execute, in order"""
    updates: [RotationUpdates!]!
  ): [RotationMutationResponse]
  """
  update data of the table: "sessions"
  """
  updateSessions(
    """sets the columns of the filtered rows to the given values"""
    _set: SessionsSetInput
    """filter the rows which have to be updated"""
    where: SessionsBoolExp!
  ): SessionsMutationResponse
  """
  update single row of the table: "sessions"
  """
  updateSessionsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: SessionsSetInput
    pkColumns: SessionsPkColumnsInput!
  ): Sessions
  """
  update multiples rows of table: "sessions"
  """
  updateSessionsMany(
    """updates to execute, in order"""
    updates: [SessionsUpdates!]!
  ): [SessionsMutationResponse]
  """
  update data of the table: "user_logins"
  """
  updateUserLogins(
    """sets the columns of the filtered rows to the given values"""
    _set: UserLoginsSetInput
    """filter the rows which have to be updated"""
    where: UserLoginsBoolExp!
  ): UserLoginsMutationResponse
  """
  update single row of the table: "user_logins"
  """
  updateUserLoginsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserLoginsSetInput
    pkColumns: UserLoginsPkColumnsInput!
  ): UserLogins
  """
  update multiples rows of table: "user_logins"
  """
  updateUserLoginsMany(
    """updates to execute, in order"""
    updates: [UserLoginsUpdates!]!
  ): [UserLoginsMutationResponse]
  """
  update data of the table: "user_rotation"
  """
  updateUserRotation(
    """sets the columns of the filtered rows to the given values"""
    _set: UserRotationSetInput
    """filter the rows which have to be updated"""
    where: UserRotationBoolExp!
  ): UserRotationMutationResponse
  """
  update single row of the table: "user_rotation"
  """
  updateUserRotationByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserRotationSetInput
    pkColumns: UserRotationPkColumnsInput!
  ): UserRotation
  """
  update multiples rows of table: "user_rotation"
  """
  updateUserRotationMany(
    """updates to execute, in order"""
    updates: [UserRotationUpdates!]!
  ): [UserRotationMutationResponse]
  """
  update data of the table: "user_sessions"
  """
  updateUserSessions(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSessionsSetInput
    """filter the rows which have to be updated"""
    where: UserSessionsBoolExp!
  ): UserSessionsMutationResponse
  """
  update single row of the table: "user_sessions"
  """
  updateUserSessionsByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UserSessionsSetInput
    pkColumns: UserSessionsPkColumnsInput!
  ): UserSessions
  """
  update multiples rows of table: "user_sessions"
  """
  updateUserSessionsMany(
    """updates to execute, in order"""
    updates: [UserSessionsUpdates!]!
  ): [UserSessionsMutationResponse]
  """
  update data of the table: "users"
  """
  updateUsers(
    """sets the columns of the filtered rows to the given values"""
    _set: UsersSetInput
    """filter the rows which have to be updated"""
    where: UsersBoolExp!
  ): UsersMutationResponse
  """
  update single row of the table: "users"
  """
  updateUsersByPk(
    """sets the columns of the filtered rows to the given values"""
    _set: UsersSetInput
    pkColumns: UsersPkColumnsInput!
  ): Users
  """
  update multiples rows of table: "users"
  """
  updateUsersMany(
    """updates to execute, in order"""
    updates: [UsersUpdates!]!
  ): [UsersMutationResponse]
}

type query_root {
  """
  fetch data from the table: "active_rotation"
  """
  activeRotation(
    """distinct select on columns"""
    distinctOn: [ActiveRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveRotationOrderBy!]
    """filter the rows returned"""
    where: ActiveRotationBoolExp
  ): [ActiveRotation!]!
  """
  fetch aggregated fields from the table: "active_rotation"
  """
  activeRotationAggregate(
    """distinct select on columns"""
    distinctOn: [ActiveRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveRotationOrderBy!]
    """filter the rows returned"""
    where: ActiveRotationBoolExp
  ): ActiveRotationAggregate!
  """
  fetch data from the table: "active_session"
  """
  activeSession(
    """distinct select on columns"""
    distinctOn: [ActiveSessionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveSessionOrderBy!]
    """filter the rows returned"""
    where: ActiveSessionBoolExp
  ): [ActiveSession!]!
  """
  fetch aggregated fields from the table: "active_session"
  """
  activeSessionAggregate(
    """distinct select on columns"""
    distinctOn: [ActiveSessionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveSessionOrderBy!]
    """filter the rows returned"""
    where: ActiveSessionBoolExp
  ): ActiveSessionAggregate!
  """An array relationship"""
  activeUsers(
    """distinct select on columns"""
    distinctOn: [ActiveUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveUsersOrderBy!]
    """filter the rows returned"""
    where: ActiveUsersBoolExp
  ): [ActiveUsers!]!
  """An aggregate relationship"""
  activeUsersAggregate(
    """distinct select on columns"""
    distinctOn: [ActiveUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveUsersOrderBy!]
    """filter the rows returned"""
    where: ActiveUsersBoolExp
  ): ActiveUsersAggregate!
  """
  fetch data from the table: "clocked_in_users"
  """
  clockedInUsers(
    """distinct select on columns"""
    distinctOn: [ClockedInUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClockedInUsersOrderBy!]
    """filter the rows returned"""
    where: ClockedInUsersBoolExp
  ): [ClockedInUsers!]!
  """
  fetch aggregated fields from the table: "clocked_in_users"
  """
  clockedInUsersAggregate(
    """distinct select on columns"""
    distinctOn: [ClockedInUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClockedInUsersOrderBy!]
    """filter the rows returned"""
    where: ClockedInUsersBoolExp
  ): ClockedInUsersAggregate!
  """
  fetch data from the table: "current_user_rotation"
  """
  currentUserRotation(
    """distinct select on columns"""
    distinctOn: [CurrentUserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentUserRotationOrderBy!]
    """filter the rows returned"""
    where: CurrentUserRotationBoolExp
  ): [CurrentUserRotation!]!
  """
  fetch aggregated fields from the table: "current_user_rotation"
  """
  currentUserRotationAggregate(
    """distinct select on columns"""
    distinctOn: [CurrentUserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentUserRotationOrderBy!]
    """filter the rows returned"""
    where: CurrentUserRotationBoolExp
  ): CurrentUserRotationAggregate!
  """
  fetch data from the table: "rooms"
  """
  rooms(
    """distinct select on columns"""
    distinctOn: [RoomsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RoomsOrderBy!]
    """filter the rows returned"""
    where: RoomsBoolExp
  ): [Rooms!]!
  """
  fetch aggregated fields from the table: "rooms"
  """
  roomsAggregate(
    """distinct select on columns"""
    distinctOn: [RoomsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RoomsOrderBy!]
    """filter the rows returned"""
    where: RoomsBoolExp
  ): RoomsAggregate!
  """fetch data from the table: "rooms" using primary key columns"""
  roomsByPk(id: uuid!): Rooms
  """
  fetch data from the table: "rotation"
  """
  rotation(
    """distinct select on columns"""
    distinctOn: [RotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RotationOrderBy!]
    """filter the rows returned"""
    where: RotationBoolExp
  ): [Rotation!]!
  """
  fetch aggregated fields from the table: "rotation"
  """
  rotationAggregate(
    """distinct select on columns"""
    distinctOn: [RotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RotationOrderBy!]
    """filter the rows returned"""
    where: RotationBoolExp
  ): RotationAggregate!
  """fetch data from the table: "rotation" using primary key columns"""
  rotationByPk(id: uuid!): Rotation
  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinctOn: [SessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SessionsOrderBy!]
    """filter the rows returned"""
    where: SessionsBoolExp
  ): [Sessions!]!
  """An aggregate relationship"""
  sessionsAggregate(
    """distinct select on columns"""
    distinctOn: [SessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SessionsOrderBy!]
    """filter the rows returned"""
    where: SessionsBoolExp
  ): SessionsAggregate!
  """fetch data from the table: "sessions" using primary key columns"""
  sessionsByPk(id: uuid!): Sessions
  """
  fetch data from the table: "user_logins"
  """
  userLogins(
    """distinct select on columns"""
    distinctOn: [UserLoginsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserLoginsOrderBy!]
    """filter the rows returned"""
    where: UserLoginsBoolExp
  ): [UserLogins!]!
  """
  fetch aggregated fields from the table: "user_logins"
  """
  userLoginsAggregate(
    """distinct select on columns"""
    distinctOn: [UserLoginsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserLoginsOrderBy!]
    """filter the rows returned"""
    where: UserLoginsBoolExp
  ): UserLoginsAggregate!
  """fetch data from the table: "user_logins" using primary key columns"""
  userLoginsByPk(id: uuid!): UserLogins
  """
  fetch data from the table: "user_rotation"
  """
  userRotation(
    """distinct select on columns"""
    distinctOn: [UserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRotationOrderBy!]
    """filter the rows returned"""
    where: UserRotationBoolExp
  ): [UserRotation!]!
  """
  fetch aggregated fields from the table: "user_rotation"
  """
  userRotationAggregate(
    """distinct select on columns"""
    distinctOn: [UserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRotationOrderBy!]
    """filter the rows returned"""
    where: UserRotationBoolExp
  ): UserRotationAggregate!
  """fetch data from the table: "user_rotation" using primary key columns"""
  userRotationByPk(id: uuid!): UserRotation
  """An array relationship"""
  userSessions(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """An aggregate relationship"""
  userSessionsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): UserSessionsAggregate!
  """fetch data from the table: "user_sessions" using primary key columns"""
  userSessionsByPk(id: uuid!): UserSessions
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): UsersAggregate!
  """fetch data from the table: "users" using primary key columns"""
  usersByPk(id: uuid!): Users
}

input sessionsAggregateBoolExpCount {
  arguments: [SessionsSelectColumn!]
  distinct: Boolean
  filter: SessionsBoolExp
  predicate: IntComparisonExp!
}

type subscription_root {
  """
  fetch data from the table: "active_rotation"
  """
  activeRotation(
    """distinct select on columns"""
    distinctOn: [ActiveRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveRotationOrderBy!]
    """filter the rows returned"""
    where: ActiveRotationBoolExp
  ): [ActiveRotation!]!
  """
  fetch aggregated fields from the table: "active_rotation"
  """
  activeRotationAggregate(
    """distinct select on columns"""
    distinctOn: [ActiveRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveRotationOrderBy!]
    """filter the rows returned"""
    where: ActiveRotationBoolExp
  ): ActiveRotationAggregate!
  """
  fetch data from the table in a streaming manner: "active_rotation"
  """
  activeRotationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ActiveRotationStreamCursorInput]!
    """filter the rows returned"""
    where: ActiveRotationBoolExp
  ): [ActiveRotation!]!
  """
  fetch data from the table: "active_session"
  """
  activeSession(
    """distinct select on columns"""
    distinctOn: [ActiveSessionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveSessionOrderBy!]
    """filter the rows returned"""
    where: ActiveSessionBoolExp
  ): [ActiveSession!]!
  """
  fetch aggregated fields from the table: "active_session"
  """
  activeSessionAggregate(
    """distinct select on columns"""
    distinctOn: [ActiveSessionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveSessionOrderBy!]
    """filter the rows returned"""
    where: ActiveSessionBoolExp
  ): ActiveSessionAggregate!
  """
  fetch data from the table in a streaming manner: "active_session"
  """
  activeSessionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ActiveSessionStreamCursorInput]!
    """filter the rows returned"""
    where: ActiveSessionBoolExp
  ): [ActiveSession!]!
  """An array relationship"""
  activeUsers(
    """distinct select on columns"""
    distinctOn: [ActiveUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveUsersOrderBy!]
    """filter the rows returned"""
    where: ActiveUsersBoolExp
  ): [ActiveUsers!]!
  """An aggregate relationship"""
  activeUsersAggregate(
    """distinct select on columns"""
    distinctOn: [ActiveUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ActiveUsersOrderBy!]
    """filter the rows returned"""
    where: ActiveUsersBoolExp
  ): ActiveUsersAggregate!
  """
  fetch data from the table in a streaming manner: "active_users"
  """
  activeUsersStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ActiveUsersStreamCursorInput]!
    """filter the rows returned"""
    where: ActiveUsersBoolExp
  ): [ActiveUsers!]!
  """
  fetch data from the table: "clocked_in_users"
  """
  clockedInUsers(
    """distinct select on columns"""
    distinctOn: [ClockedInUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClockedInUsersOrderBy!]
    """filter the rows returned"""
    where: ClockedInUsersBoolExp
  ): [ClockedInUsers!]!
  """
  fetch aggregated fields from the table: "clocked_in_users"
  """
  clockedInUsersAggregate(
    """distinct select on columns"""
    distinctOn: [ClockedInUsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ClockedInUsersOrderBy!]
    """filter the rows returned"""
    where: ClockedInUsersBoolExp
  ): ClockedInUsersAggregate!
  """
  fetch data from the table in a streaming manner: "clocked_in_users"
  """
  clockedInUsersStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ClockedInUsersStreamCursorInput]!
    """filter the rows returned"""
    where: ClockedInUsersBoolExp
  ): [ClockedInUsers!]!
  """
  fetch data from the table: "current_user_rotation"
  """
  currentUserRotation(
    """distinct select on columns"""
    distinctOn: [CurrentUserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentUserRotationOrderBy!]
    """filter the rows returned"""
    where: CurrentUserRotationBoolExp
  ): [CurrentUserRotation!]!
  """
  fetch aggregated fields from the table: "current_user_rotation"
  """
  currentUserRotationAggregate(
    """distinct select on columns"""
    distinctOn: [CurrentUserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [CurrentUserRotationOrderBy!]
    """filter the rows returned"""
    where: CurrentUserRotationBoolExp
  ): CurrentUserRotationAggregate!
  """
  fetch data from the table in a streaming manner: "current_user_rotation"
  """
  currentUserRotationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [CurrentUserRotationStreamCursorInput]!
    """filter the rows returned"""
    where: CurrentUserRotationBoolExp
  ): [CurrentUserRotation!]!
  """
  fetch data from the table: "rooms"
  """
  rooms(
    """distinct select on columns"""
    distinctOn: [RoomsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RoomsOrderBy!]
    """filter the rows returned"""
    where: RoomsBoolExp
  ): [Rooms!]!
  """
  fetch aggregated fields from the table: "rooms"
  """
  roomsAggregate(
    """distinct select on columns"""
    distinctOn: [RoomsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RoomsOrderBy!]
    """filter the rows returned"""
    where: RoomsBoolExp
  ): RoomsAggregate!
  """fetch data from the table: "rooms" using primary key columns"""
  roomsByPk(id: uuid!): Rooms
  """
  fetch data from the table in a streaming manner: "rooms"
  """
  roomsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [RoomsStreamCursorInput]!
    """filter the rows returned"""
    where: RoomsBoolExp
  ): [Rooms!]!
  """
  fetch data from the table: "rotation"
  """
  rotation(
    """distinct select on columns"""
    distinctOn: [RotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RotationOrderBy!]
    """filter the rows returned"""
    where: RotationBoolExp
  ): [Rotation!]!
  """
  fetch aggregated fields from the table: "rotation"
  """
  rotationAggregate(
    """distinct select on columns"""
    distinctOn: [RotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [RotationOrderBy!]
    """filter the rows returned"""
    where: RotationBoolExp
  ): RotationAggregate!
  """fetch data from the table: "rotation" using primary key columns"""
  rotationByPk(id: uuid!): Rotation
  """
  fetch data from the table in a streaming manner: "rotation"
  """
  rotationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [RotationStreamCursorInput]!
    """filter the rows returned"""
    where: RotationBoolExp
  ): [Rotation!]!
  """An array relationship"""
  sessions(
    """distinct select on columns"""
    distinctOn: [SessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SessionsOrderBy!]
    """filter the rows returned"""
    where: SessionsBoolExp
  ): [Sessions!]!
  """An aggregate relationship"""
  sessionsAggregate(
    """distinct select on columns"""
    distinctOn: [SessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [SessionsOrderBy!]
    """filter the rows returned"""
    where: SessionsBoolExp
  ): SessionsAggregate!
  """fetch data from the table: "sessions" using primary key columns"""
  sessionsByPk(id: uuid!): Sessions
  """
  fetch data from the table in a streaming manner: "sessions"
  """
  sessionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [SessionsStreamCursorInput]!
    """filter the rows returned"""
    where: SessionsBoolExp
  ): [Sessions!]!
  """
  fetch data from the table: "user_logins"
  """
  userLogins(
    """distinct select on columns"""
    distinctOn: [UserLoginsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserLoginsOrderBy!]
    """filter the rows returned"""
    where: UserLoginsBoolExp
  ): [UserLogins!]!
  """
  fetch aggregated fields from the table: "user_logins"
  """
  userLoginsAggregate(
    """distinct select on columns"""
    distinctOn: [UserLoginsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserLoginsOrderBy!]
    """filter the rows returned"""
    where: UserLoginsBoolExp
  ): UserLoginsAggregate!
  """fetch data from the table: "user_logins" using primary key columns"""
  userLoginsByPk(id: uuid!): UserLogins
  """
  fetch data from the table in a streaming manner: "user_logins"
  """
  userLoginsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserLoginsStreamCursorInput]!
    """filter the rows returned"""
    where: UserLoginsBoolExp
  ): [UserLogins!]!
  """
  fetch data from the table: "user_rotation"
  """
  userRotation(
    """distinct select on columns"""
    distinctOn: [UserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRotationOrderBy!]
    """filter the rows returned"""
    where: UserRotationBoolExp
  ): [UserRotation!]!
  """
  fetch aggregated fields from the table: "user_rotation"
  """
  userRotationAggregate(
    """distinct select on columns"""
    distinctOn: [UserRotationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserRotationOrderBy!]
    """filter the rows returned"""
    where: UserRotationBoolExp
  ): UserRotationAggregate!
  """fetch data from the table: "user_rotation" using primary key columns"""
  userRotationByPk(id: uuid!): UserRotation
  """
  fetch data from the table in a streaming manner: "user_rotation"
  """
  userRotationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserRotationStreamCursorInput]!
    """filter the rows returned"""
    where: UserRotationBoolExp
  ): [UserRotation!]!
  """An array relationship"""
  userSessions(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """An aggregate relationship"""
  userSessionsAggregate(
    """distinct select on columns"""
    distinctOn: [UserSessionsSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UserSessionsOrderBy!]
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): UserSessionsAggregate!
  """fetch data from the table: "user_sessions" using primary key columns"""
  userSessionsByPk(id: uuid!): UserSessions
  """
  fetch data from the table in a streaming manner: "user_sessions"
  """
  userSessionsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UserSessionsStreamCursorInput]!
    """filter the rows returned"""
    where: UserSessionsBoolExp
  ): [UserSessions!]!
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinctOn: [UsersSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [UsersOrderBy!]
    """filter the rows returned"""
    where: UsersBoolExp
  ): UsersAggregate!
  """fetch data from the table: "users" using primary key columns"""
  usersByPk(id: uuid!): Users
  """
  fetch data from the table in a streaming manner: "users"
  """
  usersStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [UsersStreamCursorInput]!
    """filter the rows returned"""
    where: UsersBoolExp
  ): [Users!]!
}

scalar timestamptz

input userSessionsAggregateBoolExpCount {
  arguments: [UserSessionsSelectColumn!]
  distinct: Boolean
  filter: UserSessionsBoolExp
  predicate: IntComparisonExp!
}

scalar uuid